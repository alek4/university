#sistemi-operativi

Le architetture dei sistemi operativi sono il modo in cui il sistema operativo è strutturato e organizzato. Ci sono diversi modi di progettare un sistema, per esempio pu; essere fatto come un unico blocco oppure, un orientamento diverso, suddividerlo in piccoli componenti, detti moduli che svolgono una piccola funzione specifica.

La struttura piu' semplice e' la struttura **monolitica**, tutte le funzionalita' del kernel vengono inserite in un singolo file binario, esse non sono ordinate e possono essere accedute da qualsiasi punto del kernel. Nonostante la sua difficolta' nell'implementarlo e manutenerlo, esso e' molto compatto e veloce grazie al ridotto overhead per le chiamate di sistema e alla sua comunicazione interna quasi istantanea.

Un'evoluzione è il sistema a struttura **gerarchica**, che organizza il sistema su livelli funzionali. Una funzione di un certo livello può chiamare solo funzioni di livello inferiore, ma non esiste ancora una separazione tra le componenti del SO. Distinguere le dipendenze gerarchiche potrebbe non essere immediato. Manutenzione ed espansione rimangono difficili, ma sono più gestibili di un sistema monolitico.

Un primo approccio modulare e' il sistema **stratificato**.
Questo modello e' definito anche come un sistema loosely coupled (sistema debolmente accoppiato) perche' e' suddiviso in componenti separate piu' piccole e con funzionalita' specifiche e limitate. Al contrario, un sistema come la struttura monolitica, e' considerata una sistema tightly coupled (strettamente accoppiato) perche' anche solo una piccola modifica potrebbe avere effetti di ampia portata anche su altre parti. Come accennato poco prima questo sistema e' composto da moduli che nascondono i propri dettagli implementativi agli altri e implementano varie funzionalita' sfruttando le varie operazioni che gli vengono offerte dagli strati inferiori. Questa struttura semplifica la progettazione e la realizzazione ma come drawback ha che le prestazioni sono scarse a causa dell'overhead dovuto alla comunicazione tra i vari strati.

Un altro approccio modulare puo' essere la struttura a **microkernel**, che rimuove dal kernel tutte le componenti non essenziali, realizzandoli come programmi di livello utente e di sistema. Il kernel cosi' creato risulta molto piccolo e possiede solo funzioni minime di gestione processi, memoria e comunicazione. lo scopo principale di questo kernel e' quello di offrire delle funzioni per la comunicazione tra i programmi client e i vari servizi. Questa comunicazione avviene tramite messaggi scambiati dal kernel e di conseguenza si crea un grande sovraccarico di gestione che incide sulle performance del sistema. D'altro canto questo approccio offre la massima separazione tra meccanismi e politiche, una facile modificabilita', la massima portabilita' e affidabilita' (se un servizio dovesse smettere di funzionare, non intacca il funzionamento del resto del sistema)

Il miglior approccio modulare e' la **struttura a moduli**, questo metodo ha un kernel che fornisce direttamente i servizi principali, mentre gli altri servizi sono implementati (caricati) in modo dinamico, mentre il kernel e' in esecuzione. Puo' essere comparato ad un sistema stratificato ma piu' flessibile perche' ogni modulo puo' chiamare qualsiasi altro modulo. Un altro approccio molto simile e' anche quello basato su microkernel, pero' e' piu' efficiente poiche' i moduli non devono invocare le funzionalita' di comunicazione, ma avviene in modo diretto.

Il kernel di un sistema a **macchine virtuali** (VM) è responsabile di fornire una copia esatta dell'hardware fisico sottostante a ogni VM eseguita in modalità utente. Ognuna di queste VM può eseguire un sistema operativo diverso. Questo permette di creare l'illusione che ogni utente abbia una macchina propria, con schedulazione e memoria virtuale che gestiscono il tempo di CPU e la memoria tra le VM, e spooling e file system che forniscono periferiche e dischi virtuali. Inoltre, l'isolamento di ogni VM dalle altre e dalla macchina fisica rende le VM adatte per testare modifiche a un sistema operativo senza causare tempi di inattività del sistema. Tuttavia, questo impedisce anche la condivisione diretta di dati e risorse tra le VM. È possibile condividere un disco virtuale tra le VM o creare una rete virtuale tra di loro per consentire la comunicazione, pur rimanendo completamente isolate. Uno svantaggio principale di questi sistemi è il calo delle prestazioni dovuto allo strato di virtualizzazione: ad esempio, se un processo in modalità utente virtuale esegue una richiesta di I/O, questa dovrà passare prima al kernel del sistema operativo della VM, quindi al software di controllo della VM (che potrebbe essere necessario interpretare la richiesta) e infine al kernel del sistema VM in modalità reale fisica, che eseguirà effettivamente la richiesta. Questo può significativamente ridurre le prestazioni.